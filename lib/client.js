// Generated by CoffeeScript 1.10.0
var Digest, UnzippingResponseDecorator, _, http, https, url,
  slice = [].slice;

https = require('https');

http = require('http');

url = require('url');

_ = require('underscore');

Digest = require('./digest');

UnzippingResponseDecorator = require('./unzipping-response-decorator');

module.exports = (function() {
  function _Class(options1) {
    this.options = options1;
    this.digests = {};
  }

  _Class.prototype.debug = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (this.options.debug) {
      return console.error.apply(console, ['DEBUG: request'].concat(slice.call(args)));
    }
  };

  _Class.prototype.request = function(options, cb) {
    var clonedOptions, currentDigest, httpOrHttps, req;
    if (options.unzip == null) {
      options.unzip = false;
    }
    this.debug('options', options);
    currentDigest = this.digests[options.host];
    clonedOptions = _.extend({}, options);
    if (currentDigest != null) {
      if (clonedOptions.headers == null) {
        clonedOptions.headers = {};
      }
      _.extend(clonedOptions.headers, {
        Authorization: currentDigest
      });
    }
    httpOrHttps = options.https ? https : http;
    req = httpOrHttps.request(clonedOptions, (function(_this) {
      return function(res) {
        var handler, handlers, msg;
        _this.debug('response status code', res.statusCode);
        _this.debug('response headers', res.headers);
        res.on('close', function(err) {
          return _this.debug('response error', err);
        });
        handlers = {};
        handlers[200] = function() {
          if (options.unzip) {
            return cb(null, new UnzippingResponseDecorator(res));
          }
          res.setEncoding('utf-8');
          return cb(null, res);
        };
        handlers[301] = handlers[302] = function() {
          var location, parsedUrl;
          _this.debug('moved', res.headers);
          location = res.headers.location;
          _this.debug('moved to', location);
          parsedUrl = url.parse(location);
          _this.debug('redirect location', parsedUrl);
          return _this.request(_.extend({}, parsedUrl, {
            https: parsedUrl.protocol === 'https',
            state: options.state,
            unzip: options.unzip
          }), cb);
        };
        handlers[401] = function() {
          var challenge, credentials, digest, msg1, msg2, ref, ref1;
          msg1 = 'wrong credentials';
          if (currentDigest != null) {
            return cb(new Error(msg1));
          }
          msg2 = 'authentication required, but `digest` option is not set';
          credentials = (ref = _this.options) != null ? (ref1 = ref.credentials) != null ? ref1[options.host] : void 0 : void 0;
          if (credentials == null) {
            return cb(new Error(msg2));
          }
          _this.debug('not authorized: authorizing');
          challenge = Digest.parseChallenge(res.headers['www-authenticate']);
          _this.debug('challenge:', challenge);
          digest = Digest.renderDigest(challenge, credentials.username, credentials.password, options.path);
          _this.digests[options.host] = digest;
          _this.debug('digest:', digest);
          return _this.request(_.extend({}, options), cb);
        };
        handler = handlers[res.statusCode];
        msg = "failed to get " + options.path + ". server status " + res.statusCode;
        if (handler == null) {
          return cb(new Error(msg));
        }
        return handler();
      };
    })(this));
    return req.end();
  };

  return _Class;

})();
